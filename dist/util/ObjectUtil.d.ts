import type { NodeObject } from 'jsonld';
import type { FunctionExecutor } from '../FunctionExecutor';
import type { SourceParser } from '../input-parser/SourceParser';
import type { MappingProcessor } from '../MappingProcessor';
import type { JSONArray, JSONObject, OrArray, PredicateObjectMap, ReferenceNodeObject, SubjectMap, TermMap, ValueObject } from './Types';
import { RR } from './Vocabulary';
export declare function addToObj(obj: Record<string, any>, pred: string, data: any): void;
export declare function addToObjAsReference(obj: Record<string, any>, pred: string, data: string): void;
export declare function getValue<T extends string | boolean | number | JSONObject | JSONArray>(fieldValue: ValueObject<T> | T): T;
export declare function getIdFromNodeObjectIfDefined(nodeObject?: ReferenceNodeObject | string): string | undefined;
export declare function findObjectWithIdInArray<T>(objArr: T[], id: string): T | undefined;
declare type RemoveEmptyReturnType<T extends OrArray<NodeObject>> = T extends NodeObject[] ? NodeObject[] : NodeObject;
export declare function removeEmptyFromAllNodes<T extends OrArray<NodeObject>>(jsonLd: T): RemoveEmptyReturnType<T>;
export declare function removeMetaFromAllNodes(jsonLd: NodeObject[]): NodeObject[];
export declare function convertRdfTypeToJsonldType(obj: Record<string, any>): void;
export declare function getConstant<T extends string | number | boolean>(constant: TermMap[typeof RR.constant]): T;
export declare function getFunctionNameFromPredicateObjectMap(predicateObjectMap: PredicateObjectMap): string | undefined;
export declare function isFnoExecutesPredicate(predicate: string): boolean;
export declare function isFunctionValuedSubjectMap(subjectMap: SubjectMap): boolean;
export declare function predicateContainsFnoExecutes(predicate: OrArray<string>): boolean;
export declare function jsonLDGraphToObj(graph: NodeObject[], deleteReplaced?: boolean): NodeObject[];
export declare function replaceReferences(graph: NodeObject[]): NodeObject[];
export declare function setObjPredicate(obj: Record<string, any>, predicate: string, dataSet: any, language?: string, datatype?: ReferenceNodeObject | string): void;
export declare function setObjPredicateWithTermType(obj: Record<string, any>, predicate: string, dataSet: any, termType: string, language?: string, datatype?: ReferenceNodeObject | string): void;
export declare function allCombinationsOfArray(arr: any[][]): string[][];
export declare function calculateTemplate(template: string, index: number, sourceParser: SourceParser<any>, termType?: string): string[];
export declare function getValueOfTermMap(termMap: TermMap, index: number, sourceParser: SourceParser<any>, topLevelMappingProcessors: Record<string, MappingProcessor>, functionExecutor: FunctionExecutor): Promise<OrArray<string>>;
export declare function getPredicateValueFromPredicateObjectMap(mapping: PredicateObjectMap, index: number, topLevelMappingProcessors: Record<string, MappingProcessor>, sourceParser: SourceParser<any>, functionExecutor: FunctionExecutor): Promise<OrArray<string>>;
export declare function isTriplesMap(node: NodeObject): boolean;
export {};
